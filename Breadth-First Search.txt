#include <stdio.h>
#include <stdlib.h>
#include <string.h> // calloc ã‚’ä½¿ã†ãŸã‚

// --- æ§‹é€ ä½“ã®å®šç¾© ---

// éš£æ¥ãƒªã‚¹ãƒˆã®ãƒãƒ¼ãƒ‰
struct Node {
    int vertex;
    struct Node* next;
};

// ã‚°ãƒ©ãƒ•æœ¬ä½“
struct Graph {
    int numVertices;
    struct Node** adjLists;
};

// ã‚­ãƒ¥ãƒ¼ï¼ˆã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆï¼‰
struct Queue {
    int* arr;
    int front; // å…ˆé ­
    int rear;  // æœ«å°¾
    int capacity;
    int currentSize; // ç¾åœ¨ã®è¦ç´ æ•°
};

// --- ã‚°ãƒ©ãƒ•æ“ä½œé–¢æ•° ---

// ãƒãƒ¼ãƒ‰ã‚’ä½œæˆ
struct Node* createNode(int v) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

// ã‚°ãƒ©ãƒ•ã‚’ä½œæˆ
struct Graph* createGraph(int vertices) {
    struct Graph* graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(struct Node*));

    for (int i = 0; i < vertices; i++) {
        graph->adjLists[i] = NULL;
    }
    return graph;
}

// ã‚¨ãƒƒã‚¸ã‚’è¿½åŠ ï¼ˆç„¡å‘ã‚°ãƒ©ãƒ•ï¼‰
void addEdge(struct Graph* graph, int src, int dest) {
    struct Node* newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    newNode = createNode(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}

// ã‚°ãƒ©ãƒ•ã®ãƒ¡ãƒ¢ãƒªè§£æ”¾
void freeGraph(struct Graph* graph) {
    for (int i = 0; i < graph->numVertices; i++) {
        struct Node* temp = graph->adjLists[i];
        while (temp) {
            struct Node* prev = temp;
            temp = temp->next;
            free(prev);
        }
    }
    free(graph->adjLists);
    free(graph);
}


// --- ã‚­ãƒ¥ãƒ¼æ“ä½œé–¢æ•° (BFSç”¨) ---

// ã‚­ãƒ¥ãƒ¼ã‚’ä½œæˆ
struct Queue* createQueue(int capacity) {
    struct Queue* queue = malloc(sizeof(struct Queue));
    queue->capacity = capacity;
    queue->front = 0;
    queue->rear = -1; // åˆæœŸçŠ¶æ…‹
    queue->currentSize = 0;
    queue->arr = malloc(queue->capacity * sizeof(int));
    return queue;
}

int isEmpty(struct Queue* queue) { return queue->currentSize == 0; }
int isFull(struct Queue* queue) { return queue->currentSize == queue->capacity; }

// ã‚­ãƒ¥ãƒ¼ã®æœ«å°¾ã«è¿½åŠ  (Enqueue)
void enqueue(struct Queue* queue, int item) {
    if (isFull(queue)) return;
    // rearã‚’å¾ªç’°ã•ã›ã‚‹
    queue->rear = (queue->rear + 1) % queue->capacity; 
    queue->arr[queue->rear] = item;
    queue->currentSize++;
}

// ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ã‹ã‚‰å–ã‚Šå‡ºã™ (Dequeue)
int dequeue(struct Queue* queue) {
    if (isEmpty(queue)) return -1;
    
    int item = queue->arr[queue->front];
    // frontã‚’å¾ªç’°ã•ã›ã‚‹
    queue->front = (queue->front + 1) % queue->capacity; 
    queue->currentSize--;
    return item;
}

// ã‚­ãƒ¥ãƒ¼ã®ãƒ¡ãƒ¢ãƒªè§£æ”¾
void freeQueue(struct Queue* queue) {
    free(queue->arr);
    free(queue);
}

// --- å¹…å„ªå…ˆæ¢ç´¢ (BFS) ---

/*
 * ç–‘ä¼¼ã‚³ãƒ¼ãƒ‰ã«æ²¿ã£ãŸBFS
 * * 1ï¼åˆæœŸçŠ¶æ…‹ã‚’ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆ(ã‚­ãƒ¥ãƒ¼)ã«å…¥ã‚Œã‚‹
 * 2ï¼ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒªã‚¹ãƒˆã‚’ç©ºã«åˆæœŸåŒ–ã™ã‚‹
 * 3ï¼Whileã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆãŒç©ºã§ã¯ãªã„
 * 4ï¼ã€€ã€€ã€€ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã‹ã‚‰å…ˆé ­ã®è¦ç´ sã‚’å–ã‚Šå‡ºã™ (Dequeue)
 * 5ï¼ã€€ã€€ã€€ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒªã‚¹ãƒˆã«sã‚’è¿½åŠ ã™ã‚‹
 * 6ï¼ã€€ã€€ã€€sãŒç›®æ¨™çŠ¶æ…‹ãªã‚‰ã°çµ‚äº†
 * 7ï¼ã€€ã€€ã€€sã‹ã‚‰æ¥ç¶šã—ã¦ã„ã¦æœªè¿½åŠ ã®çŠ¶æ…‹ã‚’ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã®æœ«å°¾ã«è¿½åŠ ã™ã‚‹ (Enqueue)
 */
void bfs_textbook(struct Graph* graph, int startVertex, int goalVertex) {
    
    // çŠ¶æ…‹ç®¡ç†ãƒ•ãƒ©ã‚° (0: æœªè¨ªå•, 1: ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆ, 2: ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒªã‚¹ãƒˆ)
    // callocã§å…¨ã¦0 (æœªè¨ªå•) ã«åˆæœŸåŒ–
    int* state = (int*)calloc(graph->numVertices, sizeof(int));

    // 1. åˆæœŸçŠ¶æ…‹ã‚’ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆ(ã‚­ãƒ¥ãƒ¼)ã«å…¥ã‚Œã‚‹
    struct Queue* openList = createQueue(graph->numVertices);
    enqueue(openList, startVertex);
    state[startVertex] = 1; // 1: ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã«è¿½åŠ æ¸ˆã¿
    
    printf("--- æ•™ç§‘æ›¸ç‰ˆBFSæ¢ç´¢é–‹å§‹ (é–‹å§‹: %d, ç›®æ¨™: %d) ---\n", startVertex, goalVertex);
    printf("ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã«è¿½åŠ  (Open): %d\n", startVertex);

    // 3. Whileã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆãŒç©ºã§ã¯ãªã„
    while (!isEmpty(openList)) {
        
        // 4. ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã‹ã‚‰å…ˆé ­ã®è¦ç´ sã‚’å–ã‚Šå‡ºã™
        int s = dequeue(openList);
        
        // 5. ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒªã‚¹ãƒˆã«sã‚’è¿½åŠ ã™ã‚‹ï¼ˆsã‚’æ¢ç´¢ã™ã‚‹ã“ã¨ã«ç›¸å½“ï¼‰
        state[s] = 2; // 2: ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒªã‚¹ãƒˆã«è¿½åŠ æ¸ˆã¿ (æ¢ç´¢å®Œäº†)
        printf("æ¢ç´¢ä¸­ (Closed): %d\n", s);
        
        // 6. sãŒç›®æ¨™çŠ¶æ…‹ãªã‚‰ã°æ¢ç´¢ã‚’çµ‚äº†
        if (s == goalVertex) {
            printf("ğŸ‰ ç›®æ¨™ %d ã‚’ç™ºè¦‹ï¼ æ¢ç´¢çµ‚äº†ã€‚\n", s);
            freeQueue(openList);
            free(state);
            return;
        }

        // 7. sã‹ã‚‰æ¥ç¶šã—ã¦ã„ã¦ã€Œã¾ã è¿½åŠ ã—ã¦ã„ãªã„çŠ¶æ…‹(state == 0)ã€ã‚’
        //    ã™ã¹ã¦ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã®æœ«å°¾ã«è¿½åŠ ã™ã‚‹
        struct Node* temp = graph->adjLists[s];
        while (temp != NULL) {
            int adjVertex = temp->vertex;
            
            // state[adjVertex] == 0 (æœªè¨ªå•) ã®å ´åˆã®ã¿
            if (state[adjVertex] == 0) {
                printf("  -> ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã«è¿½åŠ  (Open): %d\n", adjVertex);
                enqueue(openList, adjVertex);
                // ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã«è¿½åŠ ã—ãŸã®ã§ãƒãƒ¼ã‚¯ã™ã‚‹ (state = 1)
                state[adjVertex] = 1;
            }
            // æ—¢ã«ã‚ªãƒ¼ãƒ—ãƒ³(1)ã¾ãŸã¯ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰(2)ã®ãƒãƒ¼ãƒ‰ã¯ç„¡è¦–ã™ã‚‹
            
            temp = temp->next;
        }
    }
    
    // (ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆãŒç©ºã«ãªã£ãŸ)
    printf("ç›®æ¨™ %d ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n", goalVertex);

    freeQueue(openList);
    free(state);
}

// --- ãƒ¡ã‚¤ãƒ³é–¢æ•° (å®Ÿè¡Œä¾‹) ---
int main() {
    int numVertices = 5;
    struct Graph* graph = createGraph(numVertices);

    // ã‚°ãƒ©ãƒ•ã®æ§‹ç¯‰ (DFSã®æ™‚ã¨åŒã˜)
    // 0 --- 1
    // |     | \
    // 2     3  4
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 3);
    addEdge(graph, 1, 4);

    // BFSã®å®Ÿè¡Œ (ã‚¹ã‚¿ãƒ¼ãƒˆ: 0, ã‚´ãƒ¼ãƒ«: 4)
    bfs_textbook(graph, 0, 4);

    // ãƒ¡ãƒ¢ãƒªè§£æ”¾
    freeGraph(graph);

    return 0;
}