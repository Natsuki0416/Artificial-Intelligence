#include <stdio.h>
#include <stdlib.h>
#include <string.h> // calloc ã‚’ä½¿ã†ãŸã‚

// --- æ§‹é€ ä½“ã®å®šç¾© ---

// éš£æ¥ãƒªã‚¹ãƒˆã®ãƒãƒ¼ãƒ‰
struct Node {
    int vertex;
    struct Node* next;
};

// ã‚°ãƒ©ãƒ•æœ¬ä½“
struct Graph {
    int numVertices;
    struct Node** adjLists;
    // int* visited; // ã“ã®ä¾‹ã§ã¯ dfs_textbook å†…ã§è¨ªå•ç®¡ç†ã™ã‚‹ãŸã‚ä¸è¦
};

// ã‚¹ã‚¿ãƒƒã‚¯ï¼ˆã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆï¼‰
struct Stack {
    int* arr;
    int top;
    int capacity;
};

// --- ã‚°ãƒ©ãƒ•æ“ä½œé–¢æ•° ---

// ãƒãƒ¼ãƒ‰ã‚’ä½œæˆ
struct Node* createNode(int v) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

// ã‚°ãƒ©ãƒ•ã‚’ä½œæˆ
struct Graph* createGraph(int vertices) {
    struct Graph* graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(struct Node*));

    for (int i = 0; i < vertices; i++) {
        graph->adjLists[i] = NULL;
    }
    return graph;
}

// ã‚¨ãƒƒã‚¸ã‚’è¿½åŠ ï¼ˆç„¡å‘ã‚°ãƒ©ãƒ•ï¼‰
void addEdge(struct Graph* graph, int src, int dest) {
    struct Node* newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    newNode = createNode(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}

// --- ã‚¹ã‚¿ãƒƒã‚¯æ“ä½œé–¢æ•°ï¼ˆéå†å¸°DFSç”¨ï¼‰ ---

// ã‚¹ã‚¿ãƒƒã‚¯ã‚’ä½œæˆ
struct Stack* createStack(int capacity) {
    struct Stack* stack = malloc(sizeof(struct Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->arr = malloc(stack->capacity * sizeof(int));
    return stack;
}

int isEmpty(struct Stack* stack) { return stack->top == -1; }
int isFull(struct Stack* stack) { return stack->top == stack->capacity - 1; }

void push(struct Stack* stack, int item) {
    if (isFull(stack)) return;
    stack->arr[++stack->top] = item;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) return -1;
    return stack->arr[stack->top--];
}

// ã‚¹ã‚¿ãƒƒã‚¯ã®ãƒ¡ãƒ¢ãƒªè§£æ”¾
void freeStack(struct Stack* stack) {
    free(stack->arr);
    free(stack);
}

// --- æ•™ç§‘æ›¸ç‰ˆ æ·±ã•å„ªå…ˆæ¢ç´¢ (DFS) ---

/*
 * æ•™ç§‘æ›¸ã®ç–‘ä¼¼ã‚³ãƒ¼ãƒ‰ã«æ²¿ã£ãŸDFS
 * * 1ï¼åˆæœŸçŠ¶æ…‹ã‚’ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã«å…¥ã‚Œã‚‹ã€‚ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒªã‚¹ãƒˆã‚’ç©ºã«åˆæœŸåŒ–ã™ã‚‹
 * 2ï¼Whileã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆãŒç©ºã§ã¯ãªã„ã€‚do
 * 3ï¼ã€€ã€€ã€€ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã‹ã‚‰å…ˆé ­ã®è¦ç´ sã‚’å–ã‚Šå‡ºã™ã€‚ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒªã‚¹ãƒˆã«sã‚’è¿½åŠ ã™ã‚‹
 * 4ï¼ã€€ã€€ã€€sãŒç›®æ¨™çŠ¶æ…‹ãªã‚‰ã°è§£ã¯ç™ºè¦‹ã•ã‚ŒãŸã¨ã—ã¦æ¢ç´¢ã‚’çµ‚äº†
 * 5ï¼ã€€ã€€ã€€sã‹ã‚‰æ¥ç¶šã—ã¦ã„ã¦ã¾ã è¿½åŠ ã—ã¦ã„ãªã„çŠ¶æ…‹ã‚’ã™ã¹ã¦ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã®å…ˆé ­ã«è¿½åŠ ã™ã‚‹
 * 6ï¼end whileã€€æ¢ç´¢ã‚’çµ‚äº†
 */
void dfs_textbook(struct Graph* graph, int startVertex, int goalVertex) {
    
    // çŠ¶æ…‹ç®¡ç†ãƒ•ãƒ©ã‚° (0: æœªè¨ªå•, 1: ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆ, 2: ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒªã‚¹ãƒˆ)
    // callocã§å…¨ã¦0 (æœªè¨ªå•) ã«åˆæœŸåŒ–
    int* state = (int*)calloc(graph->numVertices, sizeof(int));

    // 1. åˆæœŸçŠ¶æ…‹ã‚’ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆ(ã‚¹ã‚¿ãƒƒã‚¯)ã«å…¥ã‚Œã‚‹
    struct Stack* openList = createStack(graph->numVertices);
    push(openList, startVertex);
    state[startVertex] = 1; // 1: ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã«è¿½åŠ æ¸ˆã¿
    
    printf("--- æ•™ç§‘æ›¸ç‰ˆDFSæ¢ç´¢é–‹å§‹ (é–‹å§‹: %d, ç›®æ¨™: %d) ---\n", startVertex, goalVertex);
    printf("ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã«è¿½åŠ  (Open): %d\n", startVertex);

    // 2. Whileã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆãŒç©ºã§ã¯ãªã„
    while (!isEmpty(openList)) {
        
        // 3. ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã‹ã‚‰å…ˆé ­ã®è¦ç´ sã‚’å–ã‚Šå‡ºã™
        int s = pop(openList);
        
        // ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒªã‚¹ãƒˆã«sã‚’è¿½åŠ ã™ã‚‹ï¼ˆsã‚’æ¢ç´¢ã™ã‚‹ã“ã¨ã«ç›¸å½“ï¼‰
        state[s] = 2; // 2: ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒªã‚¹ãƒˆã«è¿½åŠ æ¸ˆã¿ (æ¢ç´¢å®Œäº†)
        printf("æ¢ç´¢ä¸­ (Closed): %d\n", s);
        
        // 4. sãŒç›®æ¨™çŠ¶æ…‹ãªã‚‰ã°æ¢ç´¢ã‚’çµ‚äº†
        if (s == goalVertex) {
            printf("ğŸ‰ ç›®æ¨™ %d ã‚’ç™ºè¦‹ï¼ æ¢ç´¢çµ‚äº†ã€‚\n", s);
            freeStack(openList);
            free(state);
            return;
        }

        // 5. sã‹ã‚‰æ¥ç¶šã—ã¦ã„ã¦ã€Œã¾ã è¿½åŠ ã—ã¦ã„ãªã„çŠ¶æ…‹(state == 0)ã€ã‚’
        //    ã™ã¹ã¦ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã®å…ˆé ­ã«è¿½åŠ ã™ã‚‹
        struct Node* temp = graph->adjLists[s];
        while (temp != NULL) {
            int adjVertex = temp->vertex;
            
            // state[adjVertex] == 0 (æœªè¨ªå•) ã®å ´åˆã®ã¿
            if (state[adjVertex] == 0) {
                printf("  -> ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã«è¿½åŠ  (Open): %d\n", adjVertex);
                push(openList, adjVertex);
                // ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆã«è¿½åŠ ã—ãŸã®ã§ãƒãƒ¼ã‚¯ã™ã‚‹ (state = 1)
                state[adjVertex] = 1;
            }
            // æ—¢ã«ã‚ªãƒ¼ãƒ—ãƒ³(1)ã¾ãŸã¯ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰(2)ã®ãƒãƒ¼ãƒ‰ã¯ç„¡è¦–ã™ã‚‹
            
            temp = temp->next;
        }
    }
    
    // 6. end while (ã‚ªãƒ¼ãƒ—ãƒ³ãƒªã‚¹ãƒˆãŒç©ºã«ãªã£ãŸ)
    printf("ç›®æ¨™ %d ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n", goalVertex);

    freeStack(openList);
    free(state);
}


// --- ãƒ¡ã‚¤ãƒ³é–¢æ•° (å®Ÿè¡Œä¾‹) ---
int main() {
    int numVertices = 5;
    struct Graph* graph = createGraph(numVertices);

    // ã‚°ãƒ©ãƒ•ã®æ§‹ç¯‰
    // 0 --- 1
    // |     | \
    // 2     3  4
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 3);
    addEdge(graph, 1, 4);

    // æ•™ç§‘æ›¸ç‰ˆDFSã®å®Ÿè¡Œ (ã‚¹ã‚¿ãƒ¼ãƒˆ: 0, ã‚´ãƒ¼ãƒ«: 4)
    dfs_textbook(graph, 0, 4);

    printf("\n");

    // ã‚´ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„ä¾‹ (ã‚¹ã‚¿ãƒ¼ãƒˆ: 0, ã‚´ãƒ¼ãƒ«: 99 (å­˜åœ¨ã—ãªã„))
    dfs_textbook(graph, 0, 99);

    // ãƒ¡ãƒ¢ãƒªè§£æ”¾ (Graph)
    for (int i = 0; i < graph->numVertices; i++) {
        struct Node* temp = graph->adjLists[i];
        while (temp) {
            struct Node* prev = temp;
            temp = temp->next;
            free(prev);
        }
    }
    free(graph->adjLists);
    free(graph);

    return 0;
}